import os
import sys
import socket
import subprocess
import time
import tempfile
import json
import dateutil.parser
import urllib.request
from pathlib import Path

import certifi
from packaging.requirements import Requirement
from packaging.utils import (
    canonicalize_name,
)


class Proxy:
    """
    Wrapper for mitmproxy.org

    We start an instance of mitmproxy to intercept requests by pip
    to ensure that pip doesn't see files which were published after
    the pypiSnapshotDate given to our script.
    It's generic enough that it should work with python mirrors
    besides pypi.org as well, but URLs for actual distribution files
    should not be intercepted for performance reasons and we
    currently just ignore files.pythonhosted.org by default.
    """

    def __init__(self, executable, args, env):
        self.env = env
        self.port = self.find_free_port()

        self.proc = subprocess.Popen(
            [
                executable,
                "--listen-port",
                str(self.port),
                "--anticache",
                *args,
            ],
            stdout=sys.stderr,
            stderr=sys.stderr,
            env=env,
        )
        self.wait("http://pypi.org", 10)
        self.cafile = self.generate_ca_bundle(".ca-cert.pem")

    def find_free_port(self):
        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        sock.bind(("", 0))
        port = sock.getsockname()[1]
        sock.close()
        return port

    def wait(self, test_url, timeout):
        """
        Wait for a bit until a given url is reachable via the proxy,
        as the latter starts asynchronous.
        """
        timeout = time.time() + timeout
        req = urllib.request.Request(test_url)
        req.set_proxy(f"127.0.0.1:{self.port}", "http")

        while time.time() < timeout:
            try:
                res = urllib.request.urlopen(req, None, 5)
                if res.status < 400:
                    break
            except urllib.error.URLError:
                pass
            finally:
                time.sleep(1)

    def generate_ca_bundle(self, path):
        """
        Because we only proxy *some* calls, but ignore i.e.
        files.pythonhosted.org we need to combine upstream ca certificates
        and the one generated by mitm proxy.
        """
        home = Path(self.env["HOME"])
        path = home / path
        with open(home / ".mitmproxy/mitmproxy-ca-cert.pem", "r") as f:
            mitmproxy_cacert = f.read()
        with open(certifi.where(), "r") as f:
            certifi_cacert = f.read()
        with open(path, "w") as f:
            f.write(mitmproxy_cacert)
            f.write("\n")
            f.write(certifi_cacert)
        return path

    def kill(self):
        self.proc.kill()


def evaluate_extras(req, extras, env):
    if not extras:
        return req.marker.evaluate({**env, "extra": ""})
    else:
        return any({req.marker.evaluate({**env, "extra": e}) for e in extras})


def process_dependencies(report):
    """
    Pre-process pips report.json for easier consumation by nix.
    We extract name, version, url and hash of the source distribution or
    wheel. We also preprocess requirements and their environment markers to
    the effective, platform-specific dependencies of each package. This makes
    heavy use of `packaging` which is hard to impossible to re-implement
    correctly in nix.
    """

    packages = dict()
    installs_by_name = dict()
    env = report["environment"]
    roots = filter(lambda p: p.get("requested", False), report["install"])
    for install in report["install"]:
        name = canonicalize_name(install["metadata"]["name"])
        installs_by_name[name] = install

        download_info = install["download_info"]
        hash = (
            download_info.get("archive_info", {})
            .get("hash", "")
            .split("=", 1)  # noqa: 501
        )
        sha256 = hash[1] if hash[0] == "sha256" else None
        packages[name] = dict(
            url=download_info["url"],
            version=install["metadata"]["version"],
            sha256=sha256,
            dependencies=set(),
        )

    def walker(root, seen, extras):
        root_name = canonicalize_name(root["metadata"]["name"])

        if root_name in seen:
            print(f"cycle detected: {root_name} ({' '.join(seen)})")
            sys.exit(1)

        # we copy "seen", because we want to track cycles per tree-branch
        # and the original would be visible for all branches.
        seen = seen.copy()
        seen.append(root_name)

        reqs = map(Requirement, root["metadata"].get("requires_dist", []))
        for req in reqs:
            if (not req.marker) or evaluate_extras(req, extras, env):
                req_name = canonicalize_name(req.name)
                packages[root_name]["dependencies"].add(req_name)
                walker(installs_by_name[req_name], seen, req.extras)

    for root in roots:
        walker(root, list(), root.get("requested_extras", set()))

    packages = {
        name: {**pkg, "dependencies": sorted(list(pkg["dependencies"]))}
        for name, pkg in packages.items()
    }
    return packages


def get_max_date(snapshot_date):
    try:
        return int(snapshot_date)
    except ValueError:
        return dateutil.parser.parse(snapshot_date)


def prepare_venv(venv_path, pip_version):
    subprocess.run([sys.executable, "-m", "venv", venv_path], check=True)
    subprocess.run(
        [
            f"{venv_path}/bin/pip",
            "install",
            "--upgrade",
            f"pip=={pip_version}",
        ],
        check=True,
        stdout=sys.stderr,
        stderr=sys.stderr,
    )
    return venv_path


if __name__ == "__main__":
    with open(sys.argv[1], "r") as f:
        args = json.load(f)

    with tempfile.TemporaryDirectory() as home:
        home = Path(home)

        print(
            f"selected maximum release date for python packages: {get_max_date(args['pypiSnapshotDate'])}",  # noqa: E501
            file=sys.stderr,
        )

        proxy = Proxy(
            executable=args["mitmProxy"],
            args=[
                "--ignore-hosts",
                ".*files.pythonhosted.org.*",
                "--script",
                args["filterPypiResponsesScript"],
            ],
            env={"pypiSnapshotDate": args["pypiSnapshotDate"], "HOME": home},
        )

        venv_path = prepare_venv(
            (home / ".venv").absolute(), args["pipVersion"]
        )  # noqa: 501

        flags = args["pipFlags"] + [
            "--proxy",
            f"https://localhost:{proxy.port}",
            "--progress-bar",
            "off",
            "--cert",
            proxy.cafile,
            "--report",
            str(home / "report.json"),
        ]
        for req in args["requirementsList"]:
            if req:
                flags.append(req)
        for req in args["requirementsFiles"]:
            if req:
                flags += ["-r", req]

        subprocess.run(
            [
                f"{venv_path}/bin/pip",
                "install",
                "--dry-run",
                "--ignore-installed",
                # "--use-feature=fast-deps",
                *flags,
            ],
            check=True,
            stdout=sys.stderr,
            stderr=sys.stderr,
        )
        proxy.kill()

        with open(home / "report.json", "r") as f:
            report = json.load(f)
        with open(os.getenv("out"), "w") as f:
            packages = process_dependencies(report)
            json.dump(packages, f, indent=2, sort_keys=True)
